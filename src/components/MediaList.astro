---
import BookCard from "./BookCard.astro";
import MovieCard from "./MovieCard.astro";
import SeriesCard from "./SeriesCard.astro";

interface Props {
  items: any[];
}

const { items } = Astro.props;

// --- Build-Time Data Detection ---
const itemTypes = new Set(items.map((item) => item.data.type || "book"));
const hasBooks = itemTypes.has("book");
const hasMovies = itemTypes.has("movie");
const hasSeries = itemTypes.has("series");
const hasVisualMedia = hasMovies || hasSeries;

let dateLabel = "Finished";
if (hasBooks && !hasVisualMedia) dateLabel = "Read";
if (hasVisualMedia && !hasBooks) dateLabel = "Watched";

// --- Data Preparation for Filters ---
const allShelves = [
  ...new Set(items.map((item) => item.data.shelf).filter(Boolean)),
].sort();
const allTags = [
  ...new Set(
    items
      .flatMap((item) => item.data.tags || item.data.genre || [])
      .filter(Boolean),
  ),
].sort();
const allOwnership = [
  ...new Set(items.map((item) => (item.data.owned ? "Owned" : "Not Owned"))),
];

const components = {
  book: BookCard,
  movie: MovieCard,
  series: SeriesCard,
};

const sortedItems = [...items].sort((a, b) => {
  const titleA = a.data.sort_title || a.data.title || "";
  const titleB = b.data.sort_title || b.data.title || "";
  return titleA.localeCompare(titleB, undefined, { sensitivity: "base" });
});
---

<section class="media-container flow">
  <div class="filter-controls">
    <select class="filter-btn js-sort-by">
      <option value="sort_title-asc">Title (A-Z)</option>
      <option value="sort_title-desc">Title (Z-A)</option>

      {
        hasBooks && (
          <>
            <option value="author-asc">Author (A-Z)</option>
            <option value="author-desc">Author (Z-A)</option>
          </>
        )
      }

      {
        hasVisualMedia && (
          <>
            <option value="director-asc">Director (A-Z)</option>
            <option value="director-desc">Director (Z-A)</option>
          </>
        )
      }

      <option value="date-desc">Date {dateLabel} (Newest)</option>
      <option value="date-asc">Date {dateLabel} (Oldest)</option>
    </select>

    {
      itemTypes.size > 1 && (
        <select class="filter-btn js-filter-type">
          <option value="all">All Types</option>
          {hasBooks && <option value="book">Books</option>}
          {hasMovies && <option value="movie">Movies</option>}
          {hasSeries && <option value="series">TV Shows</option>}
        </select>
      )
    }

    {
      allShelves.length > 1 && (
        <select class="filter-btn js-filter-shelf">
          <option value="all">All Shelves</option>
          {allShelves.map((shelf) => (
            <option value={shelf}>{shelf}</option>
          ))}
        </select>
      )
    }

    {
      allTags.length > 1 && (
        <select class="filter-btn js-filter-genre">
          <option value="all">All Genres</option>
          {allTags.map((tag) => (
            <option value={tag}>{tag}</option>
          ))}
        </select>
      )
    }

    {
      allOwnership.length > 1 && (
        <select class="filter-btn js-filter-owned">
          <option value="all">All Ownership</option>
          <option value="true">Owned</option>
          <option value="false">Not Owned</option>
        </select>
      )
    }
  </div>

  <div class="media-list flow js-media-list">
    {
      sortedItems.map((item, index) => {
        const type = item.data.type || "book";
        const Card = components[type as keyof typeof components] || BookCard;

        return (
          <Card
            item={item}
            num={index}
            data-type={type}
            data-sort_title={item.data.sort_title || item.data.title}
            data-author={item.data.sort_author || item.data.author?.[0] || ""}
            data-director={item.data.sort_director || item.data.director || ""}
            data-date={item.data.end_date || item.data.watched || ""}
            data-shelf={item.data.shelf}
            data-owned={String(item.data.owned)}
            data-tags={(item.data.tags || item.data.genre || []).join(",")}
          />
        );
      })
    }
  </div>
</section>

<script>
  function initAllMediaFilters() {
    // Find all instances of media containers on the page
    const containers = document.querySelectorAll(".media-container");

    containers.forEach((container) => {
      // Find controls specific to THIS container
      const sortBy = container.querySelector(
        ".js-sort-by",
      ) as HTMLSelectElement;
      const filterType = container.querySelector(
        ".js-filter-type",
      ) as HTMLSelectElement;
      const filterShelf = container.querySelector(
        ".js-filter-shelf",
      ) as HTMLSelectElement;
      const filterGenre = container.querySelector(
        ".js-filter-genre",
      ) as HTMLSelectElement;
      const filterOwned = container.querySelector(
        ".js-filter-owned",
      ) as HTMLSelectElement;
      const mediaList = container.querySelector(
        ".js-media-list",
      ) as HTMLElement;

      if (!mediaList) return;
      const mediaItems = Array.from(
        mediaList.querySelectorAll(".card"),
      ) as HTMLElement[];

      function applyFiltersAndSort() {
        const type = filterType?.value || "all";
        const shelf = filterShelf?.value || "all";
        const genre = filterGenre?.value || "all";
        const owned = filterOwned?.value || "all";

        // 1. Filtering Logic
        mediaItems.forEach((item) => {
          const itemType = item.dataset.type || "";
          const itemShelf = item.dataset.shelf || "";
          const itemTags = (item.dataset.tags || "").split(",");
          const itemOwned = item.dataset.owned;

          const typeMatch = type === "all" || itemType === type;
          const shelfMatch = shelf === "all" || itemShelf === shelf;
          const genreMatch = genre === "all" || itemTags.includes(genre);
          const ownedMatch = owned === "all" || itemOwned === owned;

          item.style.display =
            typeMatch && shelfMatch && genreMatch && ownedMatch ? "" : "none";
        });

        // 2. Sorting Logic
        const [sortKey, sortDir] = sortBy.value.split("-");

        const sorted = [...mediaItems].sort((a, b) => {
          const aVal = a.dataset[sortKey] || "";
          const bVal = b.dataset[sortKey] || "";

          if (sortKey === "date") {
            if (!aVal) return 1;
            if (!bVal) return -1;
            const timeA = new Date(aVal).getTime();
            const timeB = new Date(bVal).getTime();
            return sortDir === "asc" ? timeA - timeB : timeB - timeA;
          }

          const comparison = aVal.localeCompare(bVal, undefined, {
            sensitivity: "base",
          });
          return sortDir === "asc" ? comparison : -comparison;
        });

        // Re-append sorted elements specifically to THIS media list
        sorted.forEach((item) => mediaList.appendChild(item));
      }

      // Attach Event Listeners to local controls
      [sortBy, filterType, filterShelf, filterGenre, filterOwned].forEach(
        (el) => {
          el?.addEventListener("change", applyFiltersAndSort);
        },
      );

      // Initial run for this instance
      applyFiltersAndSort();
    });
  }

  // Handle standard loads and View Transitions
  document.addEventListener("DOMContentLoaded", initAllMediaFilters);
  document.addEventListener("astro:after-swap", initAllMediaFilters);
</script>
