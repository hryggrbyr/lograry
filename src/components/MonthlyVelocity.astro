---
interface Props {
  items: any[];
  type: "book" | "movie" | "series" | "all";
  year: string | number; // Accept both just in case
}

const { items, type, year } = Astro.props;
const targetYear = Number(year);

// 1. Unify and Filter for the specific year
const yearFinished = items
  .map((item) => {
    const dateValue = item.data.end_date || item.data.watched;
    return dateValue ? { date: new Date(dateValue) } : null;
  })
  .filter(
    (item): item is { date: Date } =>
      item !== null && item.date.getFullYear() === targetYear,
  );

// 2. Determine labels
const labels = {
  book: "Reading",
  movie: "Viewing",
  series: "Viewing",
  all: "Consumption",
};
const dateLabel = type === "book" ? "Read" : "Watched";

// 3. Initialize 12 months (0-11)
const monthlyData = new Array(12).fill(0);

yearFinished.forEach((item) => {
  const month = item.date.getMonth();
  monthlyData[month]++;
});

const maxCount = Math.max(...monthlyData);
const monthNames = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

// 4. SVG Layout
const width = 800;
const height = 150;
const padding = 20;

const points = monthlyData
  .map((count, i) => {
    const x = (i / (monthlyData.length - 1)) * (width - padding * 2) + padding;
    const usableHeight = height - padding * 2;
    const y =
      maxCount > 0
        ? height - padding - (count / maxCount) * usableHeight
        : height - padding;
    return `${x},${y}`;
  })
  .join(" ");

// Debugging:
console.log("Input Year:", year, "Type:", typeof year);
if (items[0]) {
  const testDate = items[0].data.end_date || items[0].data.watched;
  console.log("Sample Date Value:", testDate);
  console.log("Is actual Date object?:", testDate instanceof Date);
}
---

<div class="stats-container flow">
  <div class="graph-header">
    <h3>{year} {labels[type]} Velocity</h3>
    <div class="stats-meta">
      <span>{yearFinished.length} Items {dateLabel}</span>
    </div>
  </div>

  <svg
    viewBox={`0 0 ${width} ${height}`}
    preserveAspectRatio="none"
    class="graph-svg"
  >
    <defs>
      <filter id="sketchy">
        <feTurbulence
          type="fractalNoise"
          baseFrequency="0.02 0.05"
          numOctaves="1"
          result="t"></feTurbulence>
        <feDisplacementMap in="SourceGraphic" in2="t" scale="3"
        ></feDisplacementMap>
      </filter>
    </defs>

    <line
      x1={padding}
      y1={height - padding}
      x2={width - padding}
      y2={height - padding}
      stroke="currentColor"
      opacity="0.1"></line>

    <polyline
      fill="none"
      stroke="var(--color-handwriting)"
      stroke-width="3"
      stroke-linecap="round"
      stroke-linejoin="round"
      points={points}
      filter="url(#sketchy)"></polyline>

    {
      monthNames.map((month, i) => {
        const x =
          (i / (monthNames.length - 1)) * (width - padding * 2) + padding;
        return (
          <text
            x={x}
            y={height}
            font-size="10"
            text-anchor="middle"
            fill="var(--color-text-muted)"
            style="font-family: var(--font-mono, monospace); opacity: 0.5;"
          >
            {month}
          </text>
        );
      })
    }
  </svg>
</div>

<style>
  .graph-header {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
  }
  .stats-meta {
    font-size: 0.8rem;
    opacity: 0.7;
  }
  .graph-svg {
    width: 100%;
    height: 140px; /* Increased slightly for labels */
    overflow: visible;
    display: block;
  }
</style>
